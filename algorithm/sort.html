<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>排序算法 | Sorting Algorithms</title>
    <style>
        /* CSS变量定义 - 浅色模式 */
        :root {
            --primary-color: #007bff;
            --primary-dark: #0056b3;
            --bg-color: #ffffff;
            --text-color: #333333;
            --text-light: #666666;
            --header-bg: #ffffff;
            --card-bg: #ffffff;
            --footer-bg: #333333;
            --footer-text: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --border-color: #eee;
        }
        
        /* 深色模式变量 */
        [data-theme="dark"] {
            --primary-color: #667eea;
            --primary-dark: #5568d3;
            --bg-color: #121212;
            --text-color: #ffffff;
            --text-light: #cccccc;
            --header-bg: #1e1e1e;
            --card-bg: #2a2a2a;
            --footer-bg: #1e1e1e;
            --footer-text: #cccccc;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --border-color: #333;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        /* 顶部导航栏 */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: var(--header-bg);
            box-shadow: 0 2px 5px var(--shadow-color);
        }
        
        .logo {
            display: flex;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
            text-decoration: none;
        }
        
        .logo-icon {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .logo-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .nav-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .nav-icon {
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--text-light);
            transition: color 0.3s, transform 0.3s ease;
        }
        
        .nav-icon:hover {
            color: var(--primary-color);
        }
        
        .theme-toggle {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--text-light);
            transition: color 0.3s ease, transform 0.3s ease;
            padding: 0;
            line-height: 1;
            vertical-align: middle;
            display: inline-block;
        }
        
        .theme-toggle:hover {
            color: var(--primary-color);
            transform: scale(1.3);
        }
        
        /* 主要内容区域 */
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .content-header {
            margin-bottom: 2rem;
        }
        
        .content-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: var(--text-color);
        }
        
        .content-subtitle {
            color: var(--text-light);
            font-size: 1rem;
        }
        
        .content-section {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 10px var(--shadow-color);
            margin-bottom: 2rem;
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }
        
        .section-content {
            margin-bottom: 1.5rem;
            line-height: 1.8;
        }
        
        .section-content p {
            margin-bottom: 1rem;
        }
        
        .section-content ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .section-content li {
            margin-bottom: 0.5rem;
            line-height: 1.8;
        }
        
        .code-block {
            background-color: #f5f5f5;
            border-radius: 4px;
            padding: 1rem;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        
        [data-theme="dark"] .code-block {
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 1.5rem;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 0.8rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        
        tr:hover {
            background-color: rgba(0, 123, 255, 0.05);
        }
        
        [data-theme="dark"] tr:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }
        
        /* 页脚 */
        .footer {
            background-color: var(--footer-bg);
            color: var(--footer-text);
            text-align: center;
            padding: 2rem;
            margin-top: 2rem;
        }
        
        /* 回到顶部按钮 */
        .back-to-top {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 2px 10px var(--shadow-color);
            transition: background-color 0.3s ease, transform 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }
        
        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .back-to-top:hover {
            background-color: var(--primary-dark);
            transform: scale(1.1);
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .main-content {
                padding: 1rem;
            }
            
            .content-section {
                padding: 1.5rem;
            }
            
            .content-title {
                font-size: 1.5rem;
            }
            
            .section-title {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- 顶部导航栏 -->
    <header class="header">
        <a href="../main.html" class="logo">
            <div class="logo-icon">
                <img src="../logo/Gpnu.png" alt="Logo">
            </div>
            <span>Gpnu_Acmer_Wiki</span>
        </a>
        <div class="nav-right">
            <a href="../search.html" class="nav-icon" style="text-decoration: none;">🔍</a>
            <div class="nav-icon">🔔</div>
            <button class="theme-toggle" id="theme-toggle" title="切换深色模式">🌙</button>
        </div>
    </header>

    <!-- 主要内容区域 -->
    <main class="main-content">
        <div class="content-header">
            <h1 class="content-title">排序算法</h1>
            <p class="content-subtitle">Sorting Algorithms</p>
        </div>

        <div class="content-section">
            <h2 class="section-title">1. 什么是排序算法?</h2>
            <div class="section-content">
                <p>排序算法是一种将一组数据按照特定顺序排列的算法。排序是计算机科学中最基本的操作之一，广泛应用于各种领域，如数据库查询、搜索算法、数据分析等。</p>
                <p>排序算法的优劣通常通过以下几个指标来衡量：</p>
                <ol>
                    <li><strong>时间复杂度</strong>：算法执行所需的时间，通常用大O符号表示</li>
                    <li><strong>空间复杂度</strong>：算法执行所需的额外空间</li>
                    <li><strong>稳定性</strong>：相同元素的相对位置在排序前后是否保持不变</li>
                    <li><strong>内部排序与外部排序</strong>：排序过程是否完全在内存中进行</li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">2. 排序算法的分类</h2>
            <div class="section-content">
                <p>根据排序的基本思想，排序算法可以分为以下几类：</p>
                <ol>
                    <li><strong>比较类排序</strong>：通过比较元素的大小来决定它们的相对顺序，时间复杂度通常为O(n log n)或O(n²)</li>
                    <li><strong>非比较类排序</strong>：不通过比较元素的大小来决定顺序，时间复杂度可以达到O(n)</li>
                </ol>
                <p>常见的八大排序算法包括：</p>
                <ul>
                    <li><strong>比较类排序</strong>：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序</li>
                    <li><strong>非比较类排序</strong>：计数排序</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">3. 冒泡排序 (Bubble Sort)</h2>
            <div class="section-content">
                <p>冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
                <h3>算法原理</h3>
                <p>冒泡排序的核心思想是：每次比较相邻的两个元素，如果它们的顺序错误就交换，这样每一轮遍历都会将未排序部分的最大值“冒泡”到末尾。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>比较相邻的元素。如果第一个比第二个大，就交换它们两个</li>
                    <li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对</li>
                    <li>针对所有的元素重复以上的步骤，除了最后一个</li>
                    <li>重复步骤1~3，直到排序完成</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        // 标记是否发生交换
        bool swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        // 如果本轮没有交换，说明已经有序，可以提前结束
        if (!swapped) break;
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    bubbleSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n²)，最好情况O(n)（已排序），最坏情况O(n²)（逆序）</li>
                    <li><strong>空间复杂度</strong>：O(1)</li>
                    <li><strong>稳定性</strong>：稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>简单易懂，容易实现</li>
                    <li>适用于小规模数据</li>
                    <li>效率较低，不适合大规模数据</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">4. 选择排序 (Selection Sort)</h2>
            <div class="section-content">
                <p>选择排序是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。</p>
                <h3>算法原理</h3>
                <p>选择排序的核心思想是：每次从未排序部分选择最小的元素，放到已排序部分的末尾。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>在未排序序列中找到最小元素，存放到排序序列的起始位置</li>
                    <li>再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾</li>
                    <li>重复步骤2，直到所有元素均排序完毕</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        // 找到未排序部分的最小元素下标
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 将最小元素与未排序部分的第一个元素交换
        swap(arr[i], arr[minIndex]);
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    selectionSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n²)，无论最好还是最坏情况都是O(n²)</li>
                    <li><strong>空间复杂度</strong>：O(1)</li>
                    <li><strong>稳定性</strong>：不稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>简单直观，容易实现</li>
                    <li>交换次数少，性能略优于冒泡排序</li>
                    <li>时间复杂度较高，不适合大规模数据</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">5. 插入排序 (Insertion Sort)</h2>
            <div class="section-content">
                <p>插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
                <h3>算法原理</h3>
                <p>插入排序的核心思想是：将数组分为已排序和未排序两部分，每次从未排序部分取出一个元素，插入到已排序部分的合适位置。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>将第一个元素视为已排序序列</li>
                    <li>取出下一个元素，在已排序序列中从后向前扫描</li>
                    <li>如果已排序序列中的元素大于新元素，将该元素移到下一位置</li>
                    <li>重复步骤3，直到找到已排序序列中小于或等于新元素的位置</li>
                    <li>将新元素插入到该位置后</li>
                    <li>重复步骤2~5，直到所有元素均排序完毕</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // 将大于key的元素向后移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        // 插入key到正确位置
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    insertionSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n²)，最好情况O(n)（已排序），最坏情况O(n²)（逆序）</li>
                    <li><strong>空间复杂度</strong>：O(1)</li>
                    <li><strong>稳定性</strong>：稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>简单直观，容易实现</li>
                    <li>适用于小规模数据或基本有序的数据</li>
                    <li>在实际应用中，性能通常优于冒泡排序和选择排序</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">6. 希尔排序 (Shell Sort)</h2>
            <div class="section-content">
                <p>希尔排序是插入排序的一种改进版本，它通过将整个数组分割成多个子数组分别进行插入排序，然后逐步减小子数组的间隔，最后进行一次普通的插入排序。</p>
                <h3>算法原理</h3>
                <p>希尔排序的核心思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>选择一个增量序列t1, t2, ..., tk，其中ti > tj，tk = 1</li>
                    <li>按增量序列个数k，对序列进行k趟排序</li>
                    <li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子序列进行直接插入排序</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

void shellSort(int arr[], int n) {
    // 增量序列为n/2, n/4, ..., 1
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个子序列进行插入排序
        for (int i = gap; i < n; i++) {
            int key = arr[i];
            int j = i;
            
            while (j >= gap && arr[j - gap] > key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            
            arr[j] = key;
        }
    }
}

int main() {
    int arr[] = {12, 34, 54, 2, 3};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    shellSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n^1.3)，具体取决于增量序列的选择</li>
                    <li><strong>空间复杂度</strong>：O(1)</li>
                    <li><strong>稳定性</strong>：不稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>是插入排序的改进版本，性能优于插入排序</li>
                    <li>增量序列的选择会影响排序性能</li>
                    <li>适用于中等规模的数据</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">7. 归并排序 (Merge Sort)</h2>
            <div class="section-content">
                <p>归并排序是建立在归并操作上的一种有效的排序算法，它采用分治法的思想，将数组分成两半分别排序，然后将排序好的两半合并起来。</p>
                <h3>算法原理</h3>
                <p>归并排序的核心思想是：将数组分成两半，递归地对每一半进行排序，然后将排序好的两半合并成一个有序数组。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>将数组分成两半</li>
                    <li>递归地对左半部分进行归并排序</li>
                    <li>递归地对右半部分进行归并排序</li>
                    <li>合并左右两部分有序数组</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

// 合并两个有序数组
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // 创建临时数组
    int L[n1], R[n2];
    
    // 复制数据到临时数组
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }
    
    // 合并临时数组到原数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    // 复制剩余元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序主函数
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // 计算中间位置
        int mid = left + (right - left) / 2;
        
        // 递归排序左右两部分
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        // 合并已排序的两部分
        merge(arr, left, mid, right);
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    mergeSort(arr, 0, n - 1);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n log n)，无论最好还是最坏情况都是O(n log n)</li>
                    <li><strong>空间复杂度</strong>：O(n)，需要额外的空间来存储临时数组</li>
                    <li><strong>稳定性</strong>：稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>时间复杂度稳定，不受输入数据影响</li>
                    <li>空间复杂度较高，需要额外的O(n)空间</li>
                    <li>适用于大规模数据，尤其是链表结构</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">8. 快速排序 (Quick Sort)</h2>
            <div class="section-content">
                <p>快速排序是一种高效的排序算法，它采用分治法的思想，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序。</p>
                <h3>算法原理</h3>
                <p>快速排序的核心思想是：选择一个基准元素，通过一趟排序将数组分成两部分，使得基准元素左边的所有元素都小于基准元素，右边的所有元素都大于等于基准元素，然后递归地对左右两部分进行快速排序。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>选择一个基准元素（通常是第一个或最后一个元素）</li>
                    <li>通过一趟排序将数组分成两部分，左边的元素都小于基准元素，右边的元素都大于等于基准元素</li>
                    <li>递归地对左半部分进行快速排序</li>
                    <li>递归地对右半部分进行快速排序</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

// 分区函数，返回基准元素的最终位置
int partition(int arr[], int low, int high) {
    // 选择最后一个元素作为基准
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        // 如果当前元素小于等于基准
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    // 将基准元素放到正确位置
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// 快速排序主函数
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // 分区，得到基准元素的位置
        int pi = partition(arr, low, high);
        
        // 递归排序左右两部分
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    quickSort(arr, 0, n - 1);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n log n)，最好情况O(n log n)，最坏情况O(n²)（已排序或逆序）</li>
                    <li><strong>空间复杂度</strong>：O(log n)，递归调用的栈空间</li>
                    <li><strong>稳定性</strong>：不稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>平均情况下效率很高，是实际应用中最快的排序算法之一</li>
                    <li>最坏情况时间复杂度为O(n²)，但可以通过随机选择基准元素避免</li>
                    <li>适用于大规模数据</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">9. 堆排序 (Heap Sort)</h2>
            <div class="section-content">
                <p>堆排序是一种基于比较的排序算法，它利用堆这种数据结构来进行排序。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</p>
                <h3>算法原理</h3>
                <p>堆排序的核心思想是：将待排序的序列构造成一个最大堆，此时整个序列的最大值就是堆顶的根节点，将其与末尾元素交换，然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次大值，重复这个过程，直到整个序列有序。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>将待排序的数组构建成一个最大堆</li>
                    <li>将堆顶元素（最大值）与末尾元素交换</li>
                    <li>将剩余的n-1个元素重新构建成最大堆</li>
                    <li>重复步骤2~3，直到整个数组有序</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
using namespace std;

// 调整堆，保持最大堆性质
void heapify(int arr[], int n, int i) {
    int largest = i; // 初始化最大值为根节点
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点
    
    // 如果左子节点大于根节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // 如果右子节点大于当前最大值
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 如果最大值不是根节点
    if (largest != i) {
        swap(arr[i], arr[largest]);
        
        // 递归调整受影响的子树
        heapify(arr, n, largest);
    }
}

// 堆排序主函数
void heapSort(int arr[], int n) {
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 逐个从堆中取出元素
    for (int i = n - 1; i > 0; i--) {
        // 将堆顶元素与当前末尾元素交换
        swap(arr[0], arr[i]);
        
        // 调整剩余元素为最大堆
        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    heapSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n log n)，无论最好还是最坏情况都是O(n log n)</li>
                    <li><strong>空间复杂度</strong>：O(1)</li>
                    <li><strong>稳定性</strong>：不稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>时间复杂度稳定，不受输入数据影响</li>
                    <li>空间复杂度低，不需要额外的空间</li>
                    <li>适用于大规模数据</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">10. 计数排序 (Counting Sort)</h2>
            <div class="section-content">
                <p>计数排序是一种非比较类排序算法，它通过统计数组中每个元素出现的次数，然后根据统计结果重构排序后的数组。</p>
                <h3>算法原理</h3>
                <p>计数排序的核心思想是：对于给定的输入数组中的每个元素x，确定小于x的元素个数，从而确定x在输出数组中的位置。</p>
                <h3>实现步骤</h3>
                <ol>
                    <li>找出数组中的最大值和最小值</li>
                    <li>创建一个计数数组，用于统计每个元素出现的次数</li>
                    <li>计算每个元素的累积计数，确定其在输出数组中的位置</li>
                    <li>根据计数数组重构排序后的数组</li>
                </ol>
                <h3>代码实现</h3>
                <div class="code-block">
<pre>#include <iostream>
#include <vector>
using namespace std;

void countingSort(int arr[], int n) {
    if (n <= 0) return;
    
    // 找出最大值和最小值
    int max_val = arr[0], min_val = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max_val) max_val = arr[i];
        if (arr[i] < min_val) min_val = arr[i];
    }
    
    // 创建计数数组
    int range = max_val - min_val + 1;
    vector<int> count(range, 0);
    
    // 统计每个元素出现的次数
    for (int i = 0; i < n; i++) {
        count[arr[i] - min_val]++;
    }
    
    // 重构原数组
    int index = 0;
    for (int i = 0; i < range; i++) {
        while (count[i] > 0) {
            arr[index++] = i + min_val;
            count[i]--;
        }
    }
}

int main() {
    int arr[] = {4, 2, 2, 8, 3, 3, 1};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    countingSort(arr, n);
    
    cout << "排序后的数组：";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    return 0;
}</pre>
                </div>
                <h3>复杂度分析</h3>
                <ul>
                    <li><strong>时间复杂度</strong>：O(n + k)，其中k是数据范围</li>
                    <li><strong>空间复杂度</strong>：O(k)，需要额外的计数数组</li>
                    <li><strong>稳定性</strong>：稳定</li>
                </ul>
                <h3>算法特点</h3>
                <ul>
                    <li>是非比较类排序，时间复杂度可以达到线性</li>
                    <li>适用于数据范围较小且分布均匀的情况</li>
                    <li>对于数据范围很大的情况，空间复杂度会很高</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">11. 各排序算法比较</h2>
            <div class="section-content">
                <div class="table-container">
                    <table>
                        <tr>
                            <th>排序算法</th>
                            <th>平均时间复杂度</th>
                            <th>最好情况</th>
                            <th>最坏情况</th>
                            <th>空间复杂度</th>
                            <th>稳定性</th>
                        </tr>
                        <tr>
                            <td>冒泡排序</td>
                            <td>O(n²)</td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>稳定</td>
                        </tr>
                        <tr>
                            <td>选择排序</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>不稳定</td>
                        </tr>
                        <tr>
                            <td>插入排序</td>
                            <td>O(n²)</td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>稳定</td>
                        </tr>
                        <tr>
                            <td>希尔排序</td>
                            <td>O(n^1.3)</td>
                            <td>O(n)</td>
                            <td>O(n²)</td>
                            <td>O(1)</td>
                            <td>不稳定</td>
                        </tr>
                        <tr>
                            <td>归并排序</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                            <td>稳定</td>
                        </tr>
                        <tr>
                            <td>快速排序</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n²)</td>
                            <td>O(log n)</td>
                            <td>不稳定</td>
                        </tr>
                        <tr>
                            <td>堆排序</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                            <td>不稳定</td>
                        </tr>
                        <tr>
                            <td>计数排序</td>
                            <td>O(n + k)</td>
                            <td>O(n + k)</td>
                            <td>O(n + k)</td>
                            <td>O(k)</td>
                            <td>稳定</td>
                        </tr>
                    </table>
                </div>
                <h3>排序算法的选择建议</h3>
                <ul>
                    <li><strong>小规模数据</strong>：冒泡排序、选择排序、插入排序</li>
                    <li><strong>基本有序数据</strong>：插入排序、冒泡排序</li>
                    <li><strong>大规模数据</strong>：快速排序、归并排序、堆排序</li>
                    <li><strong>数据范围小</strong>：计数排序</li>
                    <li><strong>需要稳定排序</strong>：归并排序、冒泡排序、插入排序、计数排序</li>
                    <li><strong>空间限制严格</strong>：堆排序、希尔排序、选择排序、插入排序、冒泡排序</li>
                </ul>
            </div>
        </div>

    </main>

    <!-- 页脚 -->
    <footer class="footer">
        <p>Copyright © 2025 Website Name / All Rights Reserved</p>
    </footer>

    <!-- 回到顶部按钮 -->
    <button id="back-to-top" class="back-to-top" title="回到顶部">↑</button>

    <script>
        // 深色模式切换功能
        const themeToggle = document.getElementById('theme-toggle');
        
        // 检查用户偏好或本地存储
        const currentTheme = localStorage.getItem('theme') || 
                          (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        
        // 设置初始主题
        document.documentElement.setAttribute('data-theme', currentTheme);
        themeToggle.textContent = currentTheme === 'dark' ? '☀️' : '🌙';
        
        // 切换主题
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            // 更新主题
            document.documentElement.setAttribute('data-theme', newTheme);
            themeToggle.textContent = newTheme === 'dark' ? '☀️' : '🌙';
            
            // 保存到本地存储
            localStorage.setItem('theme', newTheme);
        });

        // 回到顶部按钮功能
        const backToTopBtn = document.getElementById('back-to-top');
        
        // 监听滚动事件
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopBtn.classList.add('visible');
            } else {
                backToTopBtn.classList.remove('visible');
            }
        });
        
        // 点击回到顶部
        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
    </script>
</body>
</html>